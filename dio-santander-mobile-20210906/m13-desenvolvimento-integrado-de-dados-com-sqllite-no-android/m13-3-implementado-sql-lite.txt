Implementando SQLLite
- implementando o helper (Create) DB no app
- implementando o select/busca no app
- implementando o insert no app
- implementando o delete no app
- implementando o update no app

Implementando Helper (create) DB
- criar pasta (package) application e incluir arquivo ContatoApplication.kt (em java / com.everis.listadecontatos/application)
- ver "PrintScreen" "estrutura-de-projeto-diferente-da-padrão.PNG"

- Em ContatoApplication.kt acrescentar:

	package com.everis.listadecontatos.application /* alterar conforme a configuração pessoal */
	
	import android.app.Application

	class ContatoApplication : Application() {
		override fun onCreate() {
			super.onCreate()
		}
}

- Referenciar "ContatoApplication.kt" no "AndroidManifest.xml" acrescentando:
 
	android:name=".application.ContatoApplication"

- Criar a pasta/package helpers (dentro de "com.everis.listadecontatos") e, dentro, o arquivo HelperDB.kt
e acrescentar:

/* tem que herdar a classe SQLiteOpenHelper */
class HelperDB : SQLiteOpenHelper ( /* Observar o sugestão do Android Studio (lâmpada vermelha e clicar para inserir as informações do construtor abaixo"*/
	context: Context?,
/*	name: String?,
	factory: SQLiteDataBase.CursorFactory?,
	version: Int				*/

) : SQLiteOpenHelper(context, NOME_BANCO, factory: null, VERSAO_ATUAL) {

	companion object {
		private val NOME_BANCO = "contato.db"
		private val VERSAO_ATUAL = 1
}

	val TABLE_NAME = "contato"
	val COLUMNS_ID = "id"
	val COLUMNS_NOME = "nome"
	val COLUMNS_TELEFONE = "telefone"
		
	val DROP_TABLE = "DROP TABLE IF EXISTS $TABLE_NAME"
	val CREATE_TABLE = "CREATE TABLE $TABLE_NAME (" + 
		"$COLUMNS_ID INTEGER NOT NULL," +
		"$COLUMNS_NOME TEXT NOT NULL," +
		"$COLUMNS_TELEFONE TEXT NOT NULL," +
		"" +
		"PRIMARY KEY($COLUMNS_ID AUTOINCREMENT)" + 
		")"


	override fun onCreate(db: SQLiteDatabase?) {
		db?.execSQL(CREATE_TABLE)
	}



	/* Atualiza a tabela ao mudar a versão , isto é, qualquer alteração na estrutura da tabela*/
	override fun onUpgrade(db: SQLiteDatabase?, oldversion: Int, newVersion: Int) {
		if(oldversion != newVersion) {
			db?.execSQL(DROP_TABLE)
		}
		onCreate(db)
	}

}

- no arquivo ContatoApplication.kt

	package com.everis.listadecontatos.application /* alterar conforme a configuração pessoal */
	
	import android.app.Application

	class ContatoApplication : Application() {
		
		var helperDB : HelperDB? = null	
			private set /* Bloqueia a variável para "set" externo. Só aceitará "get" */

		override fun onCreate() {
			super.onCreate()
			helperDB = HelperDB(context: this)

		}
}


Implementando select/busca no app
- MainActivity
- Dois lugares "acessam"a lista de contatos cache (geraListaDeContato()):
	onClickBuscar() e setpListView()
- No arquivo MainActivity.kt e no evento onClickBuscar()
	
	Remover a lógica antiga que buscava os dados 

        if(!busca.isNullOrEmpty()){
            listaFiltrada = ContatoSingleton.lista.filter { contato ->
                if (contato.nome.toLowerCase().contains(busca.toLowerCase())){
                    return@filter true
                }
                return@filter false
            }
        }

- No arquivo HelperDB acrescentar 

fun buscarContatos(busca: String) : List<contatosVO> {
	val db:SQLiteDatabase! = readableDatabase ?: return mutableListOf() /* Elvis: se o DataBase for nulo retorna um tipo mutableListOf() vazio */
	
	var lista:MutableList<ContatosVO> = mutableListOf<ContatosVO>()
	val sql = "SELECT * FROM $TABLE_NAME"

	var cursor = db.rawQuery(sql, null) ?: return mutableListOf() /* Elvis: se o DataBase for nulo retorna um tipo mutableListOf() vazio */

	while (cursor.moveToNext()) {
		var contato = ContatosVO(
			cursor.getInt(cursor.getColumnIndex(COLUMNS_ID)),	/* De Para */
			cursor.getString(cursor.getColumnIndex(COLUMNS_NOME)),	/* De Para */
			cursor.getString(cursor.getColumnIndex(COLUMNS_TELEFONE)),	/* De Para */
		)
		lista.add(contato)
	}
	return lista
}

- No arquivo MainActivity e em onClickBuscar() alterar:
	var listaFiltrada: List<ContatosVO> = ContatoSingleton.lista
para 
	var listaFiltrada: List<ContatosVO> = mutableListOf()

- No arquivo ContatoApplications.kt acrescentar os códigos abaixo para transformar a class em singletron "na mão".
	class ContatoApplication : Application(){
    		var helperDB : HelperDB? = null
	        	private set //* Bloqueia a variável para "set" externo. Só aceitará "get"

    		companion object {
        		lateinit var instance: ContatoApplication
    		}

    		override fun onCreate() {
        		super.onCreate()
        		instance = this
        		helperDB = HelperDB(this)
    		}
	}

- Transformar nossa class em singleton, "na mão" é equivalente a 
		object ContatoApplication : Application(){ /* Do Java ?? */
 
	DICA : O Android só cria a instância quando "passa" pelo "super.onCreate"

- Toda chamada de "?????" deve ocorrer dentro de um "try {}" para evitar travar o app caso ocorra algum erro na consulta SQL. Veja exemplo abaixo:

         try {  
            listaFiltrada = ContatoApplication.instance.helperDB?.buscarContatos(busca) ?: mutableListOf()
        }catch (ex: Exception) {
            ex.printStackTrace()
        }

- Colocar breakpoint para ver como está funcionando 

- Alterar a versão no HelperDB.kt para poder criar o banco de dados

Implementando insert no app

Complementos do código

Implementando delete no app

Implementando SQLLite
